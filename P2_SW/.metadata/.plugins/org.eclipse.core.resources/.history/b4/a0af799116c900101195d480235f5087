#include <stdio.h>
#include <sleep.h>
#include <math.h>
#include <stdlib.h>

#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xstatus.h"

// Includes del usuario
#include "Delay.h"
#include "LCD_SPI.h"
#include "LCD_Driver.h"
#include "LCD_GUI.h"
#include "ADC.h"
#include "I2C.h"
#include "maze_game.h"
#include "maze_gui.h"
#include "Accelerometer.h"
#include "Joystick.h"
#include "MotionJoystick.h"
#include "LightSensor.h"
#include "TempSensor.h"

/* === DEFINICIONES HARDWARE === */
#define GPIO_LCD_ID         XPAR_AXI_GPIO_0_DEVICE_ID
#define SPI_LCD_ID          XPAR_AXI_QUAD_SPI_0_DEVICE_ID

// Si no está definido en xparameters, usar el ID 1 por defecto
#ifndef SPI_ADC_ID
#define SPI_ADC_ID          XPAR_AXI_QUAD_SPI_1_DEVICE_ID
#endif

/* === CONTROL === */
#define LOOP_DELAY_MS       40
#define MOVE_COOLDOWN_TICKS 5
#define TILT_THRESHOLD      0.25f

typedef enum {
    CTRL_ACCEL = 1,
    CTRL_JOYSTICK = 2
} ControlMode;

ControlMode currentControl = CTRL_ACCEL;

/* === VARIABLES GLOBALES === */
// Instancias de drivers (externas para compartir con otras librerías)
extern XGpio gpio0;
extern XSpi  SpiInstance;   /* LCD */
extern XSpi  SpiInstance1;  /* ADC */

// Objetos lógicos
LightSensor lightSensor;
TempSensor  tempSensor;

/* === FUNCIONES AUXILIARES === */

void Show_Menu(void)
{
    xil_printf("\033[2J\033[H"); // Limpiar pantalla
    xil_printf("=== LABERINTO ZYNQ INTEGRADO ===\r\n");
    xil_printf("1. Acelerometro\r\n");
    xil_printf("2. Joystick\r\n");
    xil_printf("Seleccione opcion: ");
}

/* === MAIN === */
int main(void)
{
    int Status;
    char opt;
    u32 seed_val = 0;

    // Variables de tiempo
    int game_time_seconds = 60;
    int tick_counter_1s   = 0;
    int moveCooldown      = 0;
    int debug_print_rate  = 0; // Para no saturar el UART con prints del acelerómetro

    init_platform();
    xil_printf("\r\n--- INICIO SISTEMA ---\r\n");

    /* 1. Inicialización Hardware */

    // GPIO LCD
    Status = XGpio_Initialize(&gpio0, GPIO_LCD_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // SPI LCD
    Status = XSpi_Init(&SpiInstance, SPI_LCD_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Error SPI LCD\r\n");
        return XST_FAILURE;
    }

    // SPI ADC (Joystick/Externo)
    // Inicializamos esto porque Joystick.c podría depender de SpiInstance1
    Status = XSpi_Init(&SpiInstance1, SPI_ADC_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Error SPI ADC\r\n");
        return XST_FAILURE;
    }

    // ADC Interno (XADC) para Acelerómetro
    Status = init_adc(&SpiInstance1, SPI_ADC_ID);
    if (Status != XST_SUCCESS) xil_printf("Warning: init_adc error\r\n");

    // I2C Sensores (Luz/Temp)
    Status = init_IIC();
    if (Status != XST_SUCCESS) xil_printf("Error I2C\r\n");
    else xil_printf("I2C Init OK\r\n");

    /* 2. Pantalla */
    LCD_Init(SCAN_DIR_DFT);
    LCD_Clear(WHITE);
    // GUI_INTRO(); // Puedes descomentar si quieres la intro
    // delay_ms(500);
    LCD_Clear(WHITE);

    /* 3. Objetos y Sensores */
    Accelerometer acc; Accelerometer_init(&acc);
    Joystick js;       Joystick_init(&js);
    MotionJoystick mjs; MotionJoystick_init(&mjs);

    LightSensor_init(&lightSensor);
    TempSensor_init(&tempSensor);

    /* 4. Menú */
    Show_Menu();
    opt = inbyte(); // Bloqueante
    xil_printf("%c\r\n", opt);

    // Semilla simple (podrías mejorarla leyendo un canal flotante del ADC)
    seed_val = 12345;

    if (opt == '2') {
        currentControl = CTRL_JOYSTICK;
        xil_printf("Modo: Joystick\r\n");
        LCD_Clear(WHITE);
        GUI_DisString_EN(10, 50, "Calibrando Joy...", &Font12, WHITE, RED);
        Joystick_calibrate(&js, 50);
    } else {
        currentControl = CTRL_ACCEL;
        xil_printf("Modo: Acelerometro\r\n");
        LCD_Clear(WHITE);
        GUI_DisString_EN(10, 50, "Calibrando Acc...", &Font12, WHITE, BLUE);
        Accelerometer_calibrate(&acc, 50);
    }

    LCD_Clear(WHITE);

    /* 5. Inicio Juego */
    GameState game;
    Maze_GenerateRandom(&game, seed_val); // Genera laberinto
    // Maze_InitLevel1(&game); // O usa el fijo si prefieres

    GUI_ResetDrawState();
    GUI_DrawMazeAndPlayer(&game, lightSensor.mode, tempSensor.player_color);

    /* 6. Bucle Principal */
    while (1) {

        // --- TAREA A: GESTIÓN DE TIEMPO Y SENSORES (1 Hz) ---
        // Usamos un contador simple sobre el delay del bucle
        tick_counter_1s++;
        // 25 iteraciones * 40ms = 1000ms = 1 seg
        if (tick_counter_1s >= 25) {
            tick_counter_1s = 0;

            // Leer Sensores
            LightSensor_update(&lightSensor);
            TempSensor_update(&tempSensor);

            // Imprimir estado sensores
            xil_printf("[SENSOR] Lux: %d | Temp: %d C\r\n",
                       lightSensor.lux_value, tempSensor.current_temp);

            // Restar tiempo de juego
            if (game.state == GAME_RUNNING) {
                game_time_seconds--;
                if (game_time_seconds <= 0) game.state = GAME_TIMEOUT;
            }
        }

        // --- TAREA B: LECTURA DE CONTROL Y MOVIMIENTO ---
        char dir = 0;

        if (game.state == GAME_RUNNING) {
            if (currentControl == CTRL_ACCEL) {
                float gx, gy, gz;
                float mvx, mvy;

                Accelerometer_read_g(&acc, &gx, &gy, &gz);

                // DEBUG ACELERÓMETRO (cada ~10 frames para no saturar)
                debug_print_rate++;
                if (debug_print_rate > 10) {
                    // xil_printf("ACC G: X=%.2f Y=%.2f Z=%.2f\r\n", gx, gy, gz);
                    debug_print_rate = 0;
                }

                // Ejes intercambiados (ajustar según orientación del BoosterPack)
                mvx = Accelerometer_to_movement(&acc, gy);
                mvy = Accelerometer_to_movement(&acc, gx);

                // DEBUG MOVIMIENTO CALCULADO
                // Si inclinas la placa y no ves estos valores cambiar, revisa Accelerometer_read_g
                /*
                if (fabsf(mvx) > 0.1 || fabsf(mvy) > 0.1) {
                    xil_printf("MV: X=%.2f Y=%.2f\r\n", mvx, mvy);
                }
                */

                if (fabsf(mvy) > fabsf(mvx)) {
                    if (mvy > TILT_THRESHOLD) dir = 'd';
                    else if (mvy < -TILT_THRESHOLD) dir = 'u';
                } else {
                    if (mvx > TILT_THRESHOLD) dir = 'r';
                    else if (mvx < -TILT_THRESHOLD) dir = 'l';
                }

            } else { // Joystick
                float vx, vy;
                MotionJoystick_update(&mjs, &js, &vx, &vy);

                if (fabsf(vy) > fabsf(vx)) {
                    if (vy > 0.5f) dir = 'd'; else if (vy < -0.5f) dir = 'u';
                } else {
                    if (vx > 0.5f) dir = 'r'; else if (vx < -0.5f) dir = 'l';
                }
            }

            if (moveCooldown > 0) moveCooldown--;

            if (dir != 0 && moveCooldown == 0) {
                // Intentar mover
                int res = Game_TryMove(&game, dir);
                if (res != MOVE_INVALID) {
                    moveCooldown = MOVE_COOLDOWN_TICKS;
                    xil_printf("Movimiento: %c\r\n", dir); // Confirmar que detectó dirección
                }
            }
        }

        // --- TAREA C: DIBUJAR ---
        // Pasamos el estado de los sensores para que el GUI decida los colores
        GUI_DrawMazeAndPlayer(&game, lightSensor.mode, tempSensor.player_color);

        // HUD Tiempo
        char timeStr[16];
        sprintf(timeStr, "T:%d ", game_time_seconds);

        // Colores de texto según modo Día/Noche
        uint16_t txtC = (lightSensor.mode == LIGHT_MODE_DAY) ? BLACK : WHITE;
        uint16_t bgC  = (lightSensor.mode == LIGHT_MODE_DAY) ? WHITE : BLACK;

        GUI_DisString_EN(80, 120, timeStr, &Font8, bgC, txtC);

        // --- TAREA D: CHECK FIN JUEGO ---
        if (game.state != GAME_RUNNING) {
            LCD_Clear(BLACK);
            if (game.state == GAME_WIN)
                GUI_DisString_EN(30, 50, "GANASTE!", &Font16, BLACK, GREEN);
            else if (game.state == GAME_TIMEOUT)
                GUI_DisString_EN(20, 50, "TIEMPO FUERA", &Font16, BLACK, RED);
            else
                GUI_DisString_EN(30, 50, "GAME OVER", &Font16, BLACK, RED);

            xil_printf("Juego Terminado. Estado: %d\r\n", game.state);
            while (1) { delay_ms(100); } // Fin
        }

        delay_ms(LOOP_DELAY_MS);
    }

    cleanup_platform();
    return 0;
}
