#include <stdio.h>
#include <sleep.h>
#include <stdlib.h>
#include <math.h>

#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xstatus.h"
#include "xtmrctr.h"
#include "xil_io.h"
#include "xuartps_hw.h"
#include "xscugic.h"

// Includes del usuario
#include "Delay.h"
#include "LCD_SPI.h"
#include "LCD_Driver.h"
#include "LCD_GUI.h"
#include "ADC.h"
#include "I2C.h"
#include "maze_game.h"
#include "maze_gui.h"
#include "Accelerometer.h"
#include "Joystick.h"
#include "MotionJoystick.h"
#include "LightSensor.h"
#include "TempSensor.h"

/* === DEFINICIONES HARDWARE === */
#define GPIO_LCD_ID         XPAR_AXI_GPIO_0_DEVICE_ID
#define SPI_LCD_ID          XPAR_AXI_QUAD_SPI_0_DEVICE_ID
#define SPI_ADC_ID          XPAR_AXI_QUAD_SPI_1_DEVICE_ID

// Timer 1 IRQ (el que está conectado en tu diseño)
#define TIMER_DEVICE_ID     XPAR_TMRCTR_1_DEVICE_ID
#define GIC_DEVICE_ID       XPAR_SCUGIC_0_DEVICE_ID
#define TIMER_IRQ_ID        XPAR_FABRIC_AXI_TIMER_1_INTERRUPT_INTR

/* === CONTROL === */
typedef enum {
    CTRL_ACCEL    = 1,
    CTRL_JOYSTICK = 2
} ControlMode;

ControlMode currentControl = CTRL_ACCEL;

/* === PARÁMETROS DE JUEGO / CONTROL === */
#define LOOP_DELAY_MS        1          // pequeño delay para no quemar CPU
#define MOVE_COOLDOWN_TICKS  5          // nº de ticks (40ms) entre movimientos
#define TILT_THRESHOLD       0.25f      // umbral de inclinación

/* === OBJETOS GLOBALES === */
LightSensor lightSensor;
TempSensor  tempSensor;

XTmrCtr  TimerInstance;
XScuGic  GicInstance;
XGpio    gpio0;           // GPIO del LCD
XSpi     SpiInstance;     // SPI LCD
extern XSpi SpiInstance1; // SPI ADC (definida en ADC.c)

/* === FLAGS DE TIEMPO (MODIFICADAS EN ISR) === */
volatile int tick_counter    = 0;   // cuenta ticks de 40ms
volatile int flag_game_tick  = 0;   // se pone a 1 cada tick de 40ms
volatile int flag_1sec_event = 0;   // se pone a 1 cada ~1s

/* === ISR DEL TIMER === */
void TimerCounterHandler(void *CallBackRef, u8 TmrNum)
{
    (void)CallBackRef;
    (void)TmrNum;

    flag_game_tick = 1;
    tick_counter++;

    // 25 ticks * 40ms ≈ 1 s
    if (tick_counter >= 25) {
        flag_1sec_event = 1;
        tick_counter = 0;
    }
}

/* === CONFIGURACIÓN DEL GIC === */
int SetupIntrSystem(XScuGic *GicInstancePtr, XTmrCtr *TmrInstancePtr, u16 TimerIntrId)
{
    int Status;
    XScuGic_Config *GicConfig;

    GicConfig = XScuGic_LookupConfig(GIC_DEVICE_ID);
    if (GicConfig == NULL) return XST_FAILURE;

    Status = XScuGic_CfgInitialize(GicInstancePtr,
                                   GicConfig,
                                   GicConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Conectar handler del driver del timer
    Status = XScuGic_Connect(GicInstancePtr,
                             TimerIntrId,
                             (Xil_ExceptionHandler)XTmrCtr_InterruptHandler,
                             (void *)TmrInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(GicInstancePtr, TimerIntrId);

    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 GicInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

/* === MENÚ UART === */
void Show_Menu(void)
{
    xil_printf("\033[2J\033[H");
    xil_printf("=== LABERINTO Little devi-SEP ===\r\n");
    xil_printf("1. Acelerometro\r\n");
    xil_printf("2. Joystick\r\n");
    xil_printf("Seleccion: ");
}

/* === MAIN === */
int main(void)
{
    int  Status;
    u32  seed_val;
    char opt;

    init_platform();

    /* 1. Inicialización hardware básico */
    Status = XGpio_Initialize(&gpio0, GPIO_LCD_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // SPI LCD
    Status = XSpi_Init(&SpiInstance, SPI_LCD_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;
    XSpi_SetOptions(&SpiInstance, XSP_MASTER_OPTION | XSP_MANUAL_SSELECT_OPTION);
    XSpi_Start(&SpiInstance);
    XSpi_IntrGlobalDisable(&SpiInstance);

    // SPI ADC (para joysticks / acelerómetro externo si lo hubiera)
    Status = XSpi_Init(&SpiInstance1, SPI_ADC_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;
    XSpi_SetOptions(&SpiInstance1, XSP_MASTER_OPTION | XSP_MANUAL_SSELECT_OPTION);
    XSpi_Start(&SpiInstance1);
    XSpi_IntrGlobalDisable(&SpiInstance1);

    // ADC (XADC interno, lo usas para leer joystick / acx / acy / acz)
    Status = init_adc(&SpiInstance1, SPI_ADC_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Error ADC Periferico Init. Status: %d\r\n", Status);
        return XST_FAILURE;
    }

    // I2C para sensores de luz y temperatura
    Status = init_IIC();
    if (Status != XST_SUCCESS) {
        xil_printf("Fatal Error: I2C Init Failed. Status: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("I2C Init OK\r\n");

    /* 2. LCD */
    LCD_Init(SCAN_DIR_DFT);
    LCD_Clear(WHITE);

    /* 3. Timer + Interrupciones (40 ms) */
    Status = XTmrCtr_Initialize(&TimerInstance, TIMER_DEVICE_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Error Timer Init\r\n");
        return XST_FAILURE;
    }

    // Callback del timer -> nuestra ISR de juego
    XTmrCtr_SetHandler(&TimerInstance, TimerCounterHandler, &TimerInstance);

    // 100 MHz -> 4.000.000 ciclos ≈ 40 ms
    XTmrCtr_SetResetValue(&TimerInstance, 0, 4000000U);
    XTmrCtr_SetOptions(&TimerInstance, 0,
                       XTC_INT_MODE_OPTION |
                       XTC_AUTO_RELOAD_OPTION |
                       XTC_DOWN_COUNT_OPTION);

    Status = SetupIntrSystem(&GicInstance, &TimerInstance, TIMER_IRQ_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Error GIC Init\r\n");
        return XST_FAILURE;
    }

    XTmrCtr_Start(&TimerInstance, 0);

    /* 4. Objetos de juego / sensores */
    Accelerometer acc; Accelerometer_init(&acc);
    Joystick      js;  Joystick_init(&js);
    MotionJoystick mjs; MotionJoystick_init(&mjs);

    LightSensor_init(&lightSensor);
    TempSensor_init(&tempSensor);

    /* 5. Menú de selección de control */
    Show_Menu();
    opt = inbyte();
    xil_printf("\r\nSeleccion recibida: %c\r\n", opt);

    // Semilla para laberinto aleatorio (valor actual del timer)
    seed_val = XTmrCtr_GetValue(&TimerInstance, 0);

    if (opt == '2') {
        currentControl = CTRL_JOYSTICK;
        xil_printf("Modo: Joystick\r\n");
        LCD_Clear(WHITE);
        GUI_DisString_EN(10, 50, "Calibrando Joy...", &Font12, WHITE, RED);

        // Calibración joystick
        Joystick_calibrate(&js, 50);
        xil_printf("JOY centro: %d, %d\r\n", js.center_x, js.center_y);
    } else {
        currentControl = CTRL_ACCEL;
        xil_printf("Modo: Acelerometro\r\n");
        LCD_Clear(WHITE);
        GUI_DisString_EN(10, 50, "Calibrando Acc...", &Font12, WHITE, BLUE);

        // Calibración acelerómetro
        Accelerometer_calibrate(&acc, 50);
    }

    /* 6. Inicialización del juego */
    GameState game;
    Maze_GenerateRandom(&game, seed_val);

    GUI_ResetDrawState();
    GUI_DrawMazeAndPlayer(&game, lightSensor.mode, tempSensor.player_color);

    int game_time_seconds = 60;   // tiempo total del juego
    int moveCooldown      = 0;    // ticks de espera entre movimientos

    /* 7. Bucle principal */
    while (1) {

        /* 7.1. Evento cada 1s: actualizar sensores y tiempo de juego */
        if (flag_1sec_event == 1) {
            flag_1sec_event = 0;

            // Actualizar sensores
            LightSensor_update(&lightSensor);
            TempSensor_update(&tempSensor);

            xil_printf("Luz: %d lux, Temp: %d C\r\n",
                       lightSensor.lux_value,
                       tempSensor.current_temp);

            // Contador de tiempo de juego
            if (game.state == GAME_RUNNING) {
                game_time_seconds--;
                if (game_time_seconds <= 0) {
                    game.state = GAME_TIMEOUT;
                }
            }
        }

        /* 7.2. Esperar tick de juego (40 ms). Si aún no hay tick, sigue girando */
        if (!flag_game_tick) {
            delay_ms(LOOP_DELAY_MS); // pequeño respiro a la CPU
            continue;
        }

        flag_game_tick = 0;

        /* 7.3. Lectura de control (acelerómetro o joystick) y movimiento */
        char  dir = 0;
        float mvx = 0.0f;
        float mvy = 0.0f;

        if (game.state == GAME_RUNNING) {

            if (currentControl == CTRL_ACCEL) {
                float gx, gy, gz;
                Accelerometer_read_g(&acc, &gx, &gy, &gz);

                // OJO: intercambio de ejes, según montaje físico
                mvx = Accelerometer_to_movement(&acc, gy);
                mvy = Accelerometer_to_movement(&acc, gx);
            } else {
                float nx, ny;
                MotionJoystick_update(&mjs, &js, &nx, &ny);

                // Ajuste de signos según cómo definiste MotionJoystick_update
                mvx = nx;
                mvy = -ny;
            }

            // Decidir dirección dominante
            if (fabsf(mvy) > fabsf(mvx)) {
                if (mvy >  TILT_THRESHOLD)      dir = 'd';
                else if (mvy < -TILT_THRESHOLD) dir = 'u';
            } else {
                if (mvx >  TILT_THRESHOLD)      dir = 'r';
                else if (mvx < -TILT_THRESHOLD) dir = 'l';
            }

            if (moveCooldown > 0) {
                moveCooldown--;
            }

            if (dir != 0 && moveCooldown == 0 && Game_HasFinished(&game) == GAME_RUNNING) {
                int result = Game_TryMove(&game, dir);

                if (result != MOVE_INVALID) {
                    moveCooldown = MOVE_COOLDOWN_TICKS;

                    // Debug sólo cuando realmente se mueve
                    xil_printf("Move dir=%c, mvx=%.2f, mvy=%.2f\r\n", dir, mvx, mvy);
                }
            }
        }

        /* 7.4. Dibujar laberinto + jugador con modo día/noche y color por temperatura */
        GUI_DrawMazeAndPlayer(&game, lightSensor.mode, tempSensor.player_color);

        // HUD de tiempo
        char timeStr[16];
        sprintf(timeStr, "T:%d ", game_time_seconds);

        uint16_t txtC = (lightSensor.mode == LIGHT_MODE_DAY) ? BLACK : WHITE;
        uint16_t bgC  = (lightSensor.mode == LIGHT_MODE_DAY) ? WHITE : BLACK;

        GUI_DisString_EN(80, 120, timeStr, &Font8, bgC, txtC);

        /* 7.5. Si el juego terminó (ganaste, perdiste o timeout), congelar */
        int state = Game_HasFinished(&game);
        if (state != GAME_RUNNING) {
            xil_printf("Juego terminado. Estado = %d\r\n", state);
            // Maze_GUI ya dibuja GANASTE / GAME OVER / TIMEOUT
            while (1) {
                delay_ms(100);
            }
        }
    }

    return 0;
}
