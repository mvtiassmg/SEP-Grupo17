#include <stdio.h>
#include <sleep.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>

#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xstatus.h"
#include "xscugic.h"
#include "xtmrctr.h"
#include "xil_exception.h"

#include "LCD_Driver.h"
#include "LCD_GUI.h"
#include "ADC.h"
#include "I2C.h"
#include "maze_game.h"
#include "maze_gui.h"
#include "Accelerometer.h"
#include "game_config.h"
#include "LightSensor.h"
#include "song.h"
#include "interrupts.h"   // IDs HW + extern flags/prototipos

// --- DIRECCIÓN IP AUDIO ---
#ifndef MY_PWM_BASEADDR
#define MY_PWM_BASEADDR  XPAR_BUZZERBOOSTER_DRIVER_0_S00_AXI_BASEADDR
#endif

// --- INSTANCIAS GLOBALES ---
XScuGic InterruptController; // GIC
XTmrCtr Timer0;              // Música
XTmrCtr Timer1;              // Juego
XGpio   ALightGpio;          // Sensor de luz (GPIO 1)

// Periféricos externos (definidos en otros módulos)
extern XGpio gpio0;
extern XSpi  SpiInstance;
extern XSpi  SpiInstance1;

// Instancia global del reproductor de Tetris (la usa el timer 0)
TetrisPlayer myTetris;

// --- FLAGS VOLÁTILES (compartidas con main / game_config) ---
volatile int ao2_game_tick   = 0;
volatile int ao2_light_flag  = 0;
volatile u32 debug_isr_count = 0;

// --- CONFIG DEL JUEGO ---
#define LOOP_DELAY_MS        40
#define MOVE_COOLDOWN_TICKS  5
#define TILT_THRESHOLD       0.25f

// -----------------------------------------------------------------------------
//  Helpers / Handlers de interrupción
// -----------------------------------------------------------------------------

// Convierte segundos a ticks del timer (100 MHz típico)
static u32 seconds_to_ticks(float sec)
{
    double ticks = (double)TIMER_CLOCK_HZ * (double)sec;
    if (ticks < 1.0) ticks = 1.0;
    return (u32)ticks;
}

// Timer0: Música, tick de 1 ms
static void Timer0_Handler(void *CallBackRef, u8 TmrNum)
{
    XTmrCtr *InstancePtr = (XTmrCtr *)CallBackRef;
    (void)TmrNum;

    if (XTmrCtr_IsExpired(InstancePtr, 0)) {
        XTmrCtr_Stop(InstancePtr, 0);

        // Contador de debug e integración con motor de música
        debug_isr_count++;
        Tetris_Tick_1ms(&myTetris);

        XTmrCtr_Reset(InstancePtr, 0);
        XTmrCtr_Start(InstancePtr, 0);
    }
}

// Timer1: Tick del juego (cada ~50 ms)
static void Timer1_Handler(void *CallBackRef, u8 TmrNum)
{
    XTmrCtr *InstancePtr = (XTmrCtr *)CallBackRef;
    (void)TmrNum;

    if (XTmrCtr_IsExpired(InstancePtr, 0)) {
        XTmrCtr_Stop(InstancePtr, 0);

        // Avisamos al main que hay que avanzar un paso del juego
        ao2_game_tick = 1;

        XTmrCtr_Reset(InstancePtr, 0);
        XTmrCtr_Start(InstancePtr, 0);
    }
}

// GPIO Sensor de Luz
static void Light_GPIO_Handler(void *CallBackRef)
{
    XGpio *GpioPtr = (XGpio *)CallBackRef;

    u32 status = XGpio_InterruptGetStatus(GpioPtr);
    if ((status & XGPIO_IR_CH1_MASK) != XGPIO_IR_CH1_MASK) {
        return;
    }

    // Levantamos flag para que el main lea el valor y actúe
    ao2_light_flag = 1;

    // Limpiamos el flag de interrupción
    XGpio_InterruptClear(GpioPtr, XGPIO_IR_CH1_MASK);
}

// -----------------------------------------------------------------------------
//  Funciones de configuración de interrupciones (antes estaban en interrupts.c)
// -----------------------------------------------------------------------------

int Initialize_Interrupt_Controller(XScuGic *IntcInstancePtr)
{
    int Status;
    XScuGic_Config *IntcConfig;

    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (IntcConfig == NULL) return XST_FAILURE;

    Status = XScuGic_CfgInitialize(IntcInstancePtr,
                                   IntcConfig,
                                   IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Registrar el manejador general del GIC en el ARM
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 IntcInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

int Setup_Timer0_System(XScuGic *IntcInstancePtr, XTmrCtr *TmrInstancePtr)
{
    int Status;

    // Inicializar driver del timer 0
    Status = XTmrCtr_Initialize(TmrInstancePtr, TIMER0_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Asociar nuestro handler de alto nivel al driver del timer
    XTmrCtr_SetHandler(TmrInstancePtr, Timer0_Handler, TmrInstancePtr);

    // Conectar el timer 0 al GIC usando el handler genérico de Xilinx
    Status = XScuGic_Connect(IntcInstancePtr,
                             TIMER0_IRPT_ID,
                             (Xil_ExceptionHandler)XTmrCtr_InterruptHandler,
                             TmrInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(IntcInstancePtr, TIMER0_IRPT_ID);

    // Configurar timer: modo interrupción, auto-reload, cuenta regresiva
    XTmrCtr_SetOptions(TmrInstancePtr, 0,
                       XTC_INT_MODE_OPTION |
                       XTC_AUTO_RELOAD_OPTION |
                       XTC_DOWN_COUNT_OPTION);

    // Período de 1 ms aprox
    XTmrCtr_SetResetValue(TmrInstancePtr, 0, seconds_to_ticks(TIMER0_PERIOD_SEC));

    return XST_SUCCESS;
}

int Setup_Timer1_System(XScuGic *IntcInstancePtr, XTmrCtr *TmrInstancePtr)
{
    int Status;

    // Inicializar driver del timer 1
    Status = XTmrCtr_Initialize(TmrInstancePtr, TIMER1_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_SetHandler(TmrInstancePtr, Timer1_Handler, TmrInstancePtr);

    Status = XScuGic_Connect(IntcInstancePtr,
                             TIMER1_IRPT_ID,
                             (Xil_ExceptionHandler)XTmrCtr_InterruptHandler,
                             TmrInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(IntcInstancePtr, TIMER1_IRPT_ID);

    XTmrCtr_SetOptions(TmrInstancePtr, 0,
                       XTC_INT_MODE_OPTION |
                       XTC_AUTO_RELOAD_OPTION |
                       XTC_DOWN_COUNT_OPTION);

    // Período de 50 ms aprox
    XTmrCtr_SetResetValue(TmrInstancePtr, 0, seconds_to_ticks(TIMER1_PERIOD_SEC));

    return XST_SUCCESS;
}

int Setup_GPIO_Light_System(XScuGic *IntcInstancePtr, XGpio *GpioInstancePtr)
{
    int Status;

    // Inicializar GPIO del sensor de luz
    Status = XGpio_Initialize(GpioInstancePtr, LIGHT_GPIO_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Canal como entrada
    XGpio_SetDataDirection(GpioInstancePtr, LIGHT_GPIO_CHANNEL, 0xFFFFFFFF);

    // Conectar handler al GIC
    Status = XScuGic_Connect(IntcInstancePtr,
                             LIGHT_GPIO_IRQ_ID,
                             (Xil_ExceptionHandler)Light_GPIO_Handler,
                             GpioInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(IntcInstancePtr, LIGHT_GPIO_IRQ_ID);

    // Habilitar interrupciones en el propio GPIO
    XGpio_InterruptEnable(GpioInstancePtr, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    return XST_SUCCESS;
}

void Start_Timers(XTmrCtr *Tmr0, XTmrCtr *Tmr1)
{
    XTmrCtr_Start(Tmr0, 0);
    XTmrCtr_Start(Tmr1, 0);
}

// -----------------------------------------------------------------------------
//  Wrappers para game_config.c (antes estaban en interrupts.c)
// -----------------------------------------------------------------------------

void AO2_EnableLightInterrupt(void)
{
    XGpio_InterruptEnable(&ALightGpio, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalEnable(&ALightGpio);
}

void AO2_DisableLightInterrupt(void)
{
    XGpio_InterruptDisable(&ALightGpio, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalDisable(&ALightGpio);
}

// Compatibilidad: ya no hacemos la init aquí, la hace main
int AO2_InitInterruptSystem(void)
{
    return XST_SUCCESS;
}

// -----------------------------------------------------------------------------
//  Inicialización de periféricos básicos (igual que antes)
// -----------------------------------------------------------------------------

static int init_basic_peripherals(void)
{
    int Status;

    Status = XGpio_Initialize(&gpio0, XPAR_AXI_GPIO_0_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    Status = XSpi_Init(&SpiInstance, SPI_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    Status = init_adc(&SpiInstance1, SPI_DEVICE_ID_1);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    Status = init_IIC();
    if (Status != XST_SUCCESS) return XST_FAILURE;

    return XST_SUCCESS;
}

// -----------------------------------------------------------------------------
//  MAIN
// -----------------------------------------------------------------------------

int main(void)
{
    int Status;

    init_platform();
    xil_printf("\r\n--- INICIO MAZE GAME (INTS EN main.c) ---\r\n");

    // 1. HW básico
    if (init_basic_peripherals() != XST_SUCCESS) {
        xil_printf("Fallo init_basic_peripherals\r\n");
        return -1;
    }

    // 2. Pantalla
    LCD_Init(SCAN_DIR_DFT);
    LCD_Clear(BLACK);
    GUI_DisString_EN(10, 50, "INICIANDO...", &Font16, BLACK, WHITE);

    // 3. Tetris (audio)
    Tetris_Init(&myTetris, MY_PWM_BASEADDR);

    // 4. GIC
    Status = Initialize_Interrupt_Controller(&InterruptController);
    if (Status != XST_SUCCESS) {
        xil_printf("Fallo GIC Init\r\n");
        return -1;
    }

    // 5. Timers + GPIO Luz
    Status = Setup_Timer0_System(&InterruptController, &Timer0);
    if (Status != XST_SUCCESS) xil_printf("Fallo Timer0 Setup\r\n");

    Status = Setup_Timer1_System(&InterruptController, &Timer1);
    if (Status != XST_SUCCESS) xil_printf("Fallo Timer1 Setup\r\n");

    Status = Setup_GPIO_Light_System(&InterruptController, &ALightGpio);
    if (Status != XST_SUCCESS) xil_printf("Fallo GPIO Luz Setup\r\n");

    // 6. Arrancar timers
    Start_Timers(&Timer0, &Timer1);

    // 7. Configuración por UART
    LCD_Clear(BLACK);
    GUI_DisString_EN(5, 50, "CONFIGURAR UART...", &Font12, BLACK, YELLOW);

    GameConfig cfg;
    GameConfig_ReadUART(&cfg);
    GameHardware_Init(&cfg);   // Aquí dentro se llama a AO2_EnableLightInterrupt/Disable

    if (cfg.audio_enabled) {
        Tetris_TogglePlay(&myTetris);
    }

    // 8. Calibración acelerómetro
    Accelerometer acc;
    Accelerometer_init(&acc);
    if (cfg.inputMode == 1) {
        LCD_Clear(BLACK);
        GUI_DisString_EN(10, 50, "CALIBRANDO...", &Font12, BLACK, CYAN);
        Accelerometer_calibrate(&acc, 50);
    }

    // 9. Juego
    GameState game;
    Maze_InitLevel1(&game);
    GUI_ResetDrawState();

    int themeMode   = LIGHT_MODE_DAY;
    COLOR playerColor = YELLOW;

    LCD_Clear(WHITE);
    GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);

    int moveCooldown       = 0;
    int pendingLevelChange = 0;
    int currentLevel       = 1;
    int debug_counter      = 0;
    u32 last_isr_count     = 0;

    xil_printf("Entrando al bucle principal...\r\n");

    while (1) {

        // --- Heartbeat cada ~1s para ver que las ints de música están vivas ---
        debug_counter++;
        if (debug_counter >= 25) {   // 25 * 40 ms ≈ 1 s
            u32 diff = debug_isr_count - last_isr_count;
            last_isr_count = debug_isr_count;
            xil_printf("[HEARTBEAT] INTs musica/seg: %u\r\n", (unsigned int)diff);
            debug_counter = 0;
        }

        // A) Sensor de luz por interrupción
        if (cfg.light_mode_auto && ao2_light_flag) {
            ao2_light_flag = 0;
            int luz = XGpio_DiscreteRead(&ALightGpio, LIGHT_GPIO_CHANNEL);
            xil_printf("Luz IRQ: %d\r\n", luz);

            if (luz == 0 && themeMode != LIGHT_MODE_NIGHT) {
                LCD_Clear(BLACK);
                themeMode = LIGHT_MODE_NIGHT;
                GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);
            } else if (luz != 0 && themeMode != LIGHT_MODE_DAY) {
                LCD_Clear(WHITE);
                themeMode = LIGHT_MODE_DAY;
                GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);
            }
        }

        // B) Entrada (acelerómetro o joystick)
        char dir = 0;

        if (cfg.inputMode == 1) {
            // Acelerómetro en polling (ADC SPI)
            float gx = raw_to_g(read_acx());
            float gy = raw_to_g(read_acy());

            float mvx = Accelerometer_to_movement(&acc, gy);
            float mvy = Accelerometer_to_movement(&acc, gx);

            if (fabsf(mvy) > fabsf(mvx)) {
                if (mvy >  TILT_THRESHOLD)      dir = 'd';
                else if (mvy < -TILT_THRESHOLD) dir = 'u';
            } else {
                if (mvx >  TILT_THRESHOLD)      dir = 'r';
                else if (mvx < -TILT_THRESHOLD) dir = 'l';
            }
        } else {
            // Joystick analógico
            int jx = read_joyx();
            int jy = read_joyy();

            if (jy > 2600) dir = 'u';
            if (jy < 1500) dir = 'd';
            if (jx > 2600) dir = 'r';
            if (jx < 1500) dir = 'l';
        }

        if (moveCooldown > 0) moveCooldown--;

        // C) Lógica de juego sincronizada por Timer1 (ao2_game_tick)
        if (ao2_game_tick) {
            ao2_game_tick = 0;

            if (dir != 0 && moveCooldown == 0 &&
                Game_HasFinished(&game) == GAME_RUNNING)
            {
                if (Game_TryMove(&game, dir) != MOVE_INVALID) {
                    GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);
                    moveCooldown = MOVE_COOLDOWN_TICKS;
                }
            }
        }

        // D) Estado del juego (win / lose)
        int state = Game_HasFinished(&game);

        if (state != GAME_RUNNING) {
            if (pendingLevelChange == 0) {
                GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);
                pendingLevelChange = 50;  // ~2 s
            } else if (--pendingLevelChange == 1) {
                if (state == GAME_WIN && currentLevel == 1) {
                    currentLevel = 2;
                    Maze_InitLevel2(&game);
                    GUI_ResetDrawState();
                    LCD_Clear(themeMode == LIGHT_MODE_DAY ? WHITE : BLACK);
                    GUI_DrawMazeAndPlayer(&game, themeMode, playerColor);
                } else {
                    LCD_Clear(BLACK);
                    if (state == GAME_WIN)
                        GUI_DisString_EN(10, 60, "VICTORIA!", &Font12, BLACK, GREEN);
                    else
                        GUI_DisString_EN(10, 60, "GAME OVER", &Font12, BLACK, RED);

                    if (cfg.audio_enabled)
                        Tetris_TogglePlay(&myTetris); // Stop música

                    while (1) usleep(100000);
                }
            }
        }

        usleep(40000); // ~40 ms, similar a LOOP_DELAY_MS pero sin busy-wait
    }

    cleanup_platform();
    return 0;
}
