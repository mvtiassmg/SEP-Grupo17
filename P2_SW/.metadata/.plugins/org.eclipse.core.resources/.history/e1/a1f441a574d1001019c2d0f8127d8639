#include "interrupts.h"
#include "xil_printf.h"
#include "song.h"

// --- Instancias Globales (Privadas de este archivo) ---
XScuGic INTCInst;
XTmrCtr TMR0Inst;
XTmrCtr TMR1Inst;
XGpio   ALightGpio;

// --- Instancia Externa (Música) ---
// Definimos myTetris aquí para asegurar que exista en memoria
TetrisPlayer myTetris;

// --- Flags Volátiles (Compartidas con main) ---
volatile int ao2_game_tick = 0;
volatile int ao2_light_flag = 0;
volatile u32 debug_isr_count = 0;

// Helper para calcular ticks (100MHz clock)
static u32 seconds_to_ticks(float sec) {
    return (u32)(TIMER_CLOCK_HZ * sec);
}

// ============================================================================
// 1. HANDLERS (Rutinas que se ejecutan al interrumpir)
// ============================================================================

// Handler Timer 0 (Música - 1ms)
static void Timer0_Handler(void *CallBackRef) {
    XTmrCtr *InstancePtr = (XTmrCtr *)CallBackRef;

    if (XTmrCtr_IsExpired(InstancePtr, 0)) {
        XTmrCtr_Stop(InstancePtr, 0);

        // --- Lógica Crítica ---
        debug_isr_count++;          // Contador para debug
        Tetris_Tick_1ms(&myTetris); // Avanzar música
        // ----------------------

        XTmrCtr_Reset(InstancePtr, 0);
        XTmrCtr_Start(InstancePtr, 0);
    }
}

// Handler Timer 1 (Juego - 50ms)
static void Timer1_Handler(void *CallBackRef) {
    XTmrCtr *InstancePtr = (XTmrCtr *)CallBackRef;

    if (XTmrCtr_IsExpired(InstancePtr, 0)) {
        XTmrCtr_Stop(InstancePtr, 0);

        // --- Lógica Juego ---
        ao2_game_tick = 1; // Bandera para actualizar juego en main
        // --------------------

        XTmrCtr_Reset(InstancePtr, 0);
        XTmrCtr_Start(InstancePtr, 0);
    }
}

// Handler GPIO Luz (Cambio de estado)
static void Light_GPIO_Handler(void *CallBackRef) {
    XGpio *GpioPtr = (XGpio *)CallBackRef;

    // Verificar si es la interrupción correcta (Canal 1)
    if ((XGpio_InterruptGetStatus(GpioPtr) & XGPIO_IR_CH1_MASK) != XGPIO_IR_CH1_MASK) {
        return;
    }

    // --- Lógica ---
    ao2_light_flag = 1; // Avisar al main
    // --------------

    // Limpiar flag de interrupción en el GPIO para permitir la siguiente
    XGpio_InterruptClear(GpioPtr, XGPIO_IR_CH1_MASK);
}

// ============================================================================
// 2. FUNCIONES DE CONFIGURACIÓN (Las que te faltaban)
// ============================================================================

// Inicializa solo el Controlador de Interrupciones (GIC)
int Initialize_Interrupt_Controller(XScuGic *IntcInstancePtr)
{
    int Status;
    XScuGic_Config *IntcConfig;

    // Buscar configuración
    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == IntcConfig) return XST_FAILURE;

    // Inicializar GIC
    Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Conectar GIC al procesador ARM
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 IntcInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

// Configura Timer 0 (Música)
int Setup_Timer0_System(XScuGic *IntcInstancePtr, XTmrCtr *TmrInstancePtr)
{
    int Status;

    // Inicializar Driver Timer
    Status = XTmrCtr_Initialize(TmrInstancePtr, TIMER0_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Asignar Handler local
    XTmrCtr_SetHandler(TmrInstancePtr, Timer0_Handler, TmrInstancePtr);

    // Conectar al GIC
    Status = XScuGic_Connect(IntcInstancePtr, TIMER0_IRPT_ID,
                             (Xil_ExceptionHandler)XTmrCtr_InterruptHandler,
                             TmrInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Habilitar en GIC
    XScuGic_Enable(IntcInstancePtr, TIMER0_IRPT_ID);

    // Configurar Timer: Down Count + Auto Reload
    XTmrCtr_SetOptions(TmrInstancePtr, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);
    XTmrCtr_SetResetValue(TmrInstancePtr, 0, seconds_to_ticks(TIMER0_PERIOD_SEC));

    return XST_SUCCESS;
}

// Configura Timer 1 (Juego)
int Setup_Timer1_System(XScuGic *IntcInstancePtr, XTmrCtr *TmrInstancePtr)
{
    int Status;

    Status = XTmrCtr_Initialize(TmrInstancePtr, TIMER1_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_SetHandler(TmrInstancePtr, Timer1_Handler, TmrInstancePtr);

    Status = XScuGic_Connect(IntcInstancePtr, TIMER1_IRPT_ID,
                             (Xil_ExceptionHandler)XTmrCtr_InterruptHandler,
                             TmrInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XScuGic_Enable(IntcInstancePtr, TIMER1_IRPT_ID);

    XTmrCtr_SetOptions(TmrInstancePtr, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);
    XTmrCtr_SetResetValue(TmrInstancePtr, 0, seconds_to_ticks(TIMER1_PERIOD_SEC));

    return XST_SUCCESS;
}

// Configura GPIO Luz
int Setup_GPIO_Light_System(XScuGic *IntcInstancePtr, XGpio *GpioInstancePtr)
{
    int Status;

    // Inicializar Driver GPIO
    Status = XGpio_Initialize(GpioInstancePtr, LIGHT_GPIO_DEVICE_ID);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Dirección: Entrada
    XGpio_SetDataDirection(GpioInstancePtr, LIGHT_GPIO_CHANNEL, 0xFFFFFFFF);

    // Conectar Handler al GIC
    Status = XScuGic_Connect(IntcInstancePtr, LIGHT_GPIO_IRQ_ID,
                             (Xil_ExceptionHandler)Light_GPIO_Handler,
                             GpioInstancePtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // Habilitar en GIC
    XScuGic_Enable(IntcInstancePtr, LIGHT_GPIO_IRQ_ID);

    // Habilitar Interrupciones en el periférico GPIO
    XGpio_InterruptEnable(GpioInstancePtr, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    return XST_SUCCESS;
}

// Arranca los timers
void Start_Timers(XTmrCtr *Tmr0, XTmrCtr *Tmr1) {
    XTmrCtr_Start(Tmr0, 0);
    XTmrCtr_Start(Tmr1, 0);
}

// ============================================================================
// 3. FUNCIONES AUXILIARES (Para game_config.c)
// ============================================================================

void AO2_EnableLightInterrupt(void) {
    XGpio_InterruptEnable(&ALightGpio, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalEnable(&ALightGpio);
}

void AO2_DisableLightInterrupt(void) {
    XGpio_InterruptDisable(&ALightGpio, XGPIO_IR_CH1_MASK);
    XGpio_InterruptGlobalDisable(&ALightGpio);
}

// Wrapper de compatibilidad (por si algo viejo lo llama, aunque ya no debería)
int AO2_InitInterruptSystem() {
    return XST_SUCCESS;
}
