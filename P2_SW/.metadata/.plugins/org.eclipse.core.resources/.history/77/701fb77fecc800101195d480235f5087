#include "ADC.h"
#include "xadcps.h"
#include "xparameters.h"
#include "xstatus.h"
#include "xil_printf.h" // Para debug

// ID del XADC (interno del PS)
#define XADC_DEVICE_ID 		XPAR_XADCPS_0_DEVICE_ID

static XAdcPs XAdcInst;      /* XADC driver instance */
static int IsInitialized = 0;

// Mantenemos la firma antigua pero ignoramos los parámetros de SPI
int init_adc(XSpi *SpiPtr, u16 SpiDeviceId)
{
    int Status;
    XAdcPs_Config *ConfigPtr;

    if (IsInitialized) return XST_SUCCESS;

    xil_printf("ADC: Iniciando XADC...\r\n");

    ConfigPtr = XAdcPs_LookupConfig(XADC_DEVICE_ID);
    if (ConfigPtr == NULL) {
        xil_printf("ADC: Error LookupConfig\r\n");
        return XST_FAILURE;
    }

    Status = XAdcPs_CfgInitialize(&XAdcInst, ConfigPtr, ConfigPtr->BaseAddress);
    if (Status != XST_SUCCESS) {
        xil_printf("ADC: Error CfgInitialize\r\n");
        return XST_FAILURE;
    }

    Status = XAdcPs_SelfTest(&XAdcInst);
    if (Status != XST_SUCCESS) {
        xil_printf("ADC: Error SelfTest\r\n");
        return XST_FAILURE;
    }

    // Configurar para modo secuenciador seguro (lectura continua de todos los canales)
    XAdcPs_SetSequencerMode(&XAdcInst, XADCPS_SEQ_MODE_SAFE);

    // Habilitar canales auxiliares si es necesario (depende del hardware, pero safe mode suele bastar)
    // XAdcPs_SetSeqChEnables(&XAdcInst, XADCPS_SEQ_CH_AUX00 | ...);

    IsInitialized = 1;
    xil_printf("ADC: Inicializacion Exitosa\r\n");
    return XST_SUCCESS;
}

// Función genérica de lectura
u32 read_adc(int channel)
{
    if (!IsInitialized) return 0;

    // Mapeo de canales 0-15 a canales auxiliares XADC (16-31)
    // El BoosterPack MKII suele usar Aux 14 (X), Aux 7 (Y), Aux 15 (Z) para acelerómetro
    // Y Joystick Aux 2 y Aux 10 (ejemplos, verificar hardware)

    u8 XAdcChannel;
    // Si el canal es pequeño (0-15), asumimos que es un índice de auxiliar
    if (channel < 16) {
        XAdcChannel = XADCPS_CH_AUX_MIN + channel;
    } else {
        XAdcChannel = channel;
    }

    // Leer y convertir (12 bits significativos)
    // XAdcPs_GetAdcData devuelve el valor más reciente convertido automáticamente
    u32 raw_data = XAdcPs_GetAdcData(&XAdcInst, XAdcChannel);

    // El resultado está alineado a la izquierda (16 bits), desplazamos 4 para tener 12 bits (0-4095)
    return (raw_data >> 4);
}

// Implementación de las funciones que usa tu código legado
// Estos canales (14, 7, 15) son típicos para el acelerómetro en la Zybo con este BoosterPack
// Si obtienes ceros, prueba otros canales o imprime todos los canales auxiliares para encontrar los activos.
int read_acx()  { return (int)read_adc(14); }
int read_acy()  { return (int)read_adc(7); }
int read_acz()  { return (int)read_adc(15); }

// Joystick (Ajustar canales si es necesario)
int read_joyx() { return (int)read_adc(2); }
int read_joyy() { return (int)read_adc(10); }

int read_POT1() { return 0; }
int read_POT2() { return 0; }
int read_MIC()  { return 0; }
