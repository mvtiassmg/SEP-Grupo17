#include "xparameters.h"
#include "xgpio.h"   // <-- offsets oficiales del AXI GPIO
#include "xil_io.h"
#include "sleep.h"
#include <stdint.h>
#include <stdbool.h>
#include "songs.h"

/* ---- Base addresses (Address Editor) ---- */
#define GPIO0_BASE   XPAR_AXI_GPIO_0_BASEADDR   // botones + RGB
#define GPIO1_BASE   XPAR_AXI_GPIO_1_BASEADDR   // leds + enable
#define GPIO2_BASE   XPAR_AXI_GPIO_2_BASEADDR   // selector

#define TICK_MS      1

/* ---- Helpers (todo activo-alto) ---- */
static inline uint32_t read_buttons(void)  { return Xil_In32(GPIO0_BASE + XGPIO_DATA_OFFSET); }
static inline uint32_t read_selector(void) { return Xil_In32(GPIO2_BASE + XGPIO_DATA_OFFSET); }
static inline bool     read_enable(void)   { return (Xil_In32(GPIO1_BASE + XGPIO_DATA2_OFFSET)) != 0; }

static inline void write_leds(uint8_t p)   { Xil_Out32(GPIO1_BASE + XGPIO_DATA_OFFSET,  p & 0xF); }
static inline void rgb(bool r, bool g, bool b) {
    uint32_t v = (r?1u:0u) | (g?2u:0u) | (b?4u:0u);           // R=bit0, G=bit1, B=bit2
    Xil_Out32(GPIO0_BASE + XGPIO_DATA2_OFFSET, v);
}

int main(void)
{	 XGpio & GPIO;
    /* Direcciones (TRI: 1=entrada, 0=salida) */

    Xil_Out32(GPIO0_BASE + XGPIO_TRI_OFFSET,   0xFFFFFFFFu); // CH1 botones IN
    Xil_Out32(GPIO0_BASE + XGPIO_TRI2_OFFSET,  0x00000000u); // CH2 RGB OUT

    Xil_Out32(GPIO1_BASE + XGPIO_TRI_OFFSET,   0x00000000u); // CH1 leds OUT
    Xil_Out32(GPIO1_BASE + XGPIO_TRI2_OFFSET,  0xFFFFFFFFu); // CH2 enable IN

    Xil_Out32(GPIO2_BASE + XGPIO_TRI_OFFSET,   0xFFFFFFFFu); // CH1 selector IN

    write_leds(0); rgb(0,0,0);

    uint32_t tick = 0, idx = 0, sel_prev = 0xFFFFFFFFu;
    SongRef sr = g_songs[0];

    while (1) {
        if (!read_enable()) {               // pausa global
            write_leds(0); rgb(0,0,0);
            usleep(TICK_MS*1000);
            continue;
        }

        uint32_t sel = read_selector();     // canciÃ³n por switches
        if (sel != sel_prev || idx >= sr.len) {
            sr = g_songs[ sel % g_songs_count ];
            sel_prev = sel;
            idx = 0; tick = 0;
            write_leds(0); rgb(0,0,0);
        }

        while (idx < sr.len && sr.ev[idx].tick <= tick) {
            uint8_t patt = sr.ev[idx].leds & 0xF;
            write_leds(patt);

            uint32_t btn = read_buttons();
            if      (patt == 0)   rgb(0,0,0);
            else if (btn == patt) rgb(0,1,0);   // correcto
            else                  rgb(1,0,0);   // incorrecto
            idx++;
        }

        usleep(TICK_MS*1000);
        tick += TICK_MS;

        if (idx >= sr.len) {
            usleep(200000);
            idx = 0; tick = 0;
            write_leds(0); rgb(0,0,0);
        }
    }
}
