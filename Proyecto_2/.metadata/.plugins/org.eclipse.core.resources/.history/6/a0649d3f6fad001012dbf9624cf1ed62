#include "xparameters.h"
#include "xgpio_l.h"   // offsets: XGPIO_DATA_OFFSET, XGPIO_DATA2_OFFSET, XGPIO_TRI_OFFSET, XGPIO_TRI2_OFFSET
#include "xil_io.h"
#include "sleep.h"
#include <stdint.h>
#include <stdbool.h>
#include "songs.h"     // Event, SongRef, g_songs, g_songs_count

/******** Base addresses (Address Editor) ********/
#define GPIO0_BASE   XPAR_AXI_GPIO_0_BASEADDR   // botones + RGB
#define GPIO1_BASE   XPAR_AXI_GPIO_1_BASEADDR   // leds + enable
#define GPIO2_BASE   XPAR_AXI_GPIO_2_BASEADDR   // selector

/******** Utilidad simple ********/
#define TICK_MS      1

static inline uint32_t in_ch1(uint32_t base)        { return Xil_In32(base + XGPIO_DATA_OFFSET);  }
static inline uint32_t in_ch2(uint32_t base)        { return Xil_In32(base + XGPIO_DATA2_OFFSET); }
static inline void     out_ch1(uint32_t base, uint32_t v){ Xil_Out32(base + XGPIO_DATA_OFFSET,  v); }
static inline void     out_ch2(uint32_t base, uint32_t v){ Xil_Out32(base + XGPIO_DATA2_OFFSET, v); }

static inline void cfg_dir(void){
    /* TRI: 1 = IN, 0 = OUT */
    Xil_Out32(GPIO0_BASE + XGPIO_TRI_OFFSET,   0xFFFFFFFFu); // CH1 botones IN
    Xil_Out32(GPIO0_BASE + XGPIO_TRI2_OFFSET,  0x00000000u); // CH2 RGB OUT
    Xil_Out32(GPIO1_BASE + XGPIO_TRI_OFFSET,   0x00000000u); // CH1 leds OUT
    Xil_Out32(GPIO1_BASE + XGPIO_TRI2_OFFSET,  0xFFFFFFFFu); // CH2 enable IN
    Xil_Out32(GPIO2_BASE + XGPIO_TRI_OFFSET,   0xFFFFFFFFu); // CH1 selector IN
}

/******** I/O alto nivel (todo activo-alto) ********/
static inline uint32_t read_buttons(void)  { return in_ch1(GPIO0_BASE) & 0xF; }
static inline uint32_t read_selector(void) { return in_ch1(GPIO2_BASE) & 0x3; }
static inline bool     read_enable(void)   { return (in_ch2(GPIO1_BASE) & 0x1) != 0; }

static inline void write_leds(uint8_t p)   { out_ch1(GPIO1_BASE, (uint32_t)(p & 0xF)); }
static inline void rgb(bool r,bool g,bool b){
    uint32_t v = (r?1u:0u) | (g?2u:0u) | (b?4u:0u);   // R=bit0, G=bit1, B=bit2
    out_ch2(GPIO0_BASE, v);
}

/******** Programa ********/
int main(void)
{
    cfg_dir();
    write_leds(0); rgb(0,0,0);

    /* --- PRUEBA RÁPIDA: parpadeo de LEDs 1s (confirma wiring) --- */
    for (int i=0; i<4; ++i){
        write_leds(0xF); usleep(200*1000);
        write_leds(0x0); usleep(200*1000);
    }

    /* Juego simple con canciones */
    uint32_t tick = 0, idx = 0, sel_prev = 0xFFFFFFFFu;
    SongRef sr = g_songs[0];

    while (1){
        /* Enable global (GPIO1 CH2 bit0) */
        if (!read_enable()){
            write_leds(0); rgb(0,0,0);
            usleep(TICK_MS*1000);
            continue;
        }

        /* Selector de canción (GPIO2 CH1 [1:0]) */
        uint32_t sel = read_selector();
        if (sel != sel_prev || idx >= sr.len){
            sr = g_songs[ sel % g_songs_count ];
            sel_prev = sel;
            idx = 0; tick = 0;
            write_leds(0); rgb(0,0,0);
        }

        /* Dispara eventos al tiempo */
        while (idx < sr.len && sr.ev[idx].tick <= tick){
            uint8_t patt = sr.ev[idx].leds & 0xF;
            write_leds(patt);

            uint32_t btn = read_buttons();
            if      (patt == 0)    rgb(0,0,0);
            else if (btn == patt)  rgb(0,1,0);     // acierto
            else                   rgb(1,0,0);     // error
            idx++;
        }

        usleep(TICK_MS*1000);
        tick += TICK_MS;

        if (idx >= sr.len){
            usleep(200*1000);
            idx = 0; tick = 0;
            write_leds(0); rgb(0,0,0);
        }
    }
    // return 0;
}
