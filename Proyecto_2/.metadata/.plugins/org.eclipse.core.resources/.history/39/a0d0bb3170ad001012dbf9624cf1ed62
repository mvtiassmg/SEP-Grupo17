#include "xparameters.h"
#include "xgpio.h"     // Driver oficial AXI GPIO
#include "sleep.h"
#include <stdint.h>
#include <stdbool.h>
#include "songs.h"

// No necesitamos xil_io.h porque usaremos el driver

#define TICK_MS     1 // Duración de cada "tick" del juego en milisegundos

/* ---- Instancias del Driver GPIO ---- */
// Necesitamos UNA instancia por CADA periférico AXI GPIO en el diagrama
XGpio Gpio0_ButtonsRGB; // Conectado a botones (CH1) y RGB (CH2)
XGpio Gpio1_LedsEnable; // Conectado a leds (CH1) y enable (CH2)
XGpio Gpio2_Selector;   // Conectado a selector (CH1)


/* ---- Funciones Helper (ahora usan el driver) ---- */
static inline uint32_t read_buttons(void)  { return XGpio_DiscreteRead(&Gpio0_ButtonsRGB, 1); }
static inline uint32_t read_selector(void) { return XGpio_DiscreteRead(&Gpio2_Selector, 1); }
static inline bool     read_enable(void)   { return (XGpio_DiscreteRead(&Gpio1_LedsEnable, 2)) != 0; }

static inline void write_leds(uint8_t p)   { XGpio_DiscreteWrite(&Gpio1_LedsEnable, 1, p & 0xF); }
static inline void rgb(bool r, bool g, bool b) {
    uint32_t v = (r?1u:0u) | (g?2u:0u) | (b?4u:0u); // R=bit0, G=bit1, B=bit2
    XGpio_DiscreteWrite(&Gpio0_ButtonsRGB, 2, v);
}

int main(void)
{
    int status;

    /* ---- Inicialización de los Drivers ---- */
    // 1. Inicializar GPIO 0 (Botones + RGB)
    status = XGpio_Initialize(&Gpio0_ButtonsRGB, XPAR_AXI_GPIO_0_DEVICE_ID);
    if (status != XST_SUCCESS) { return XST_FAILURE; }

    // 2. Inicializar GPIO 1 (Leds + Enable)
    status = XGpio_Initialize(&Gpio1_LedsEnable, XPAR_AXI_GPIO_1_DEVICE_ID);
    if (status != XST_SUCCESS) { return XST_FAILURE; }

    // 3. Inicializar GPIO 2 (Selector)
    status = XGpio_Initialize(&Gpio2_Selector, XPAR_AXI_GPIO_2_DEVICE_ID);
    if (status != XST_SUCCESS) { return XST_FAILURE; }


    /* ---- Configuración de Dirección (TRI) ---- */
    // GPIO 0: CH1 botones (IN), CH2 RGB (OUT)
    XGpio_SetDataDirection(&Gpio0_ButtonsRGB, 1, 0xFFFFFFFF); // CH1 = Input
    XGpio_SetDataDirection(&Gpio0_ButtonsRGB, 2, 0x00000000); // CH2 = Output

    // GPIO 1: CH1 leds (OUT), CH2 enable (IN)
    XGpio_SetDataDirection(&Gpio1_LedsEnable, 1, 0x00000000); // CH1 = Output
    XGpio_SetDataDirection(&Gpio1_LedsEnable, 2, 0xFFFFFFFF); // CH2 = Input

    // GPIO 2: CH1 selector (IN)
    XGpio_SetDataDirection(&Gpio2_Selector, 1, 0xFFFFFFFF); // CH1 = Input


    /* ---- Lógica del Juego ---- */
    write_leds(0); rgb(0,0,0);

    uint32_t tick = 0, idx = 0, sel_prev = 0xFFFFFFFFu;
    SongRef sr = g_songs[0];

    // Variable de ESTADO: almacena el patrón de LED actual que el jugador debe presionar
    uint8_t current_pattern = 0;

    while (1) {
        // --- Pausa Global ---
        if (!read_enable()) {
            write_leds(0); rgb(0,0,0);
            current_pattern = 0; // Resetea el patrón
            usleep(TICK_MS*1000);
            continue;
        }

        // --- Selección de Canción ---
        uint32_t sel = read_selector();
        // Si la canción cambia O si la canción terminó (idx >= sr.len)
        if (sel != sel_prev || idx >= sr.len) {
            sr = g_songs[ sel % g_songs_count ];
            sel_prev = sel;
            idx = 0; tick = 0;
            current_pattern = 0;
            write_leds(0); rgb(0,0,0);

            if (idx >= sr.len) { // Si fue por fin de canción, añade pausa
                 usleep(200000); // Pausa de 200ms
            }
        }

        // --- Procesamiento de Eventos (Actualizar LEDs) ---
        // Comprueba si en el 'tick' actual debe ocurrir un nuevo evento
        if (idx < sr.len && sr.ev[idx].tick <= tick) {
            current_pattern = sr.ev[idx].leds & 0xF;
            write_leds(current_pattern);
            idx++; // Avanza al siguiente evento
        }

        // --- Procesamiento de Entrada (Comprobar Botones) ---
        // Esto ocurre en CADA tick, permitiendo al jugador reaccionar
        uint32_t btn = read_buttons();

        if (current_pattern == 0) {
            rgb(0,0,0); // No hay nota activa, RGB apagado
        } else if (btn == 0) {
            // Hay nota activa, pero no se presiona nada = ERROR (Miss)
            rgb(1,0,0);
        } else if (btn == current_pattern) {
            // Hay nota activa y se presiona la correcta = OK
            rgb(0,1,0);
        } else {
            // Hay nota activa y se presiona la incorrecta = ERROR
            rgb(1,0,0);
        }

        // --- Avanzar el tiempo del juego ---
        usleep(TICK_MS*1000);
        tick += TICK_MS;
    }
}
