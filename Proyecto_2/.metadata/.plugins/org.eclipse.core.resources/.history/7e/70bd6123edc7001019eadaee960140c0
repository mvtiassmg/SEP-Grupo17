include "maze_game.h"
#include <stdio.h>

void Maze_InitLevel1(GameState *game)
{
    Maze *m = &game->maze;
    Player *p = &game->player;

    // Laberinto 10x10 (más grande y con más ramificaciones)
    m->rows = 10;
    m->cols = 10;

    // Primero llenamos TODO con muros
    for (int r = 0; r < m->rows; r++) {
        for (int c = 0; c < m->cols; c++) {
            m->cells[r][c] = CELL_WALL;
        }
    }

    /* Diseño del Usuario */

    // Fila 0, columnas 0..2
    for (int c = 0; c <= 2; c++) {
        m->cells[0][c] = CELL_PATH;
    }

    // Columna 2, filas 1..2
    for (int r = 1; r <= 2; r++) {
        m->cells[r][2] = CELL_PATH;
    }

    // Fila 2, columnas 3..4 (además de la col 2 ya marcada)
    for (int c = 3; c <= 4; c++) {
        m->cells[2][c] = CELL_PATH;
    }

    // Fila 1, columnas 4..6
    for (int c = 4; c <= 6; c++) {
        m->cells[1][c] = CELL_PATH;
    }

    // Columna 6, filas 2..4
    for (int r = 2; r <= 4; r++) {
        m->cells[r][6] = CELL_PATH;
    }

    // Columna 5, filas 4..7
    for (int r = 4; r <= 7; r++) {
        m->cells[r][5] = CELL_PATH;
    }

    // Fila 7, columnas 5..7
    for (int c = 5; c <= 7; c++) {
        m->cells[7][c] = CELL_PATH;
    }

    // Columna 7, filas 8..9
    for (int r = 8; r <= 9; r++) {
        m->cells[r][7] = CELL_PATH;
    }

    // Fila 9, columna 8 (la 9 será la salida)
    m->cells[9][8] = CELL_PATH;

    // Salida en (9,9)
    m->exitRow = 9;
    m->exitCol = 9;
    m->cells[9][9] = CELL_EXIT;

    /* ====== Ramificaciones / trampas ====== */

    // Ramita cerca del inicio
    m->cells[1][1] = CELL_PATH;
    m->cells[1][0] = CELL_TRAP;

    // Trampa arriba de (2,3)
    m->cells[1][3] = CELL_TRAP;

    // Corredor a la derecha de (4,6) con trampa al final
    m->cells[4][7] = CELL_PATH;
    m->cells[4][8] = CELL_PATH;
    m->cells[4][9] = CELL_TRAP;

    // Ramita vertical desde (7,7) hacia arriba con trampa
    m->cells[6][7] = CELL_PATH;
    m->cells[5][7] = CELL_TRAP;

    // Un espacio extra cerca del final
    m->cells[8][6] = CELL_PATH;

    // Inicio del jugador
    m->startRow = 0;
    m->startCol = 0;

    p->row   = m->startRow;
    p->col   = m->startCol;
    p->lives = 3;
    p->score = 0;

    game->state = GAME_RUNNING;
}

void Maze_InitLevel2(GameState *game)
{
    Maze *m = &game->maze;
    Player *p = &game->player;

    m->rows = 10;
    m->cols = 10;

    // Limpiar todo a muros
    for (int r = 0; r < m->rows; r++) {
        for (int c = 0; c < m->cols; c++) {
            m->cells[r][c] = CELL_WALL;
        }
    }

    // Diseño de "Espiral Cuadrada" hacia el centro
    // Borde externo
    for(int c=0; c<10; c++) m->cells[0][c] = CELL_PATH; // Top
    for(int r=0; r<10; r++) m->cells[r][9] = CELL_PATH; // Right
    for(int c=0; c<10; c++) m->cells[9][c] = CELL_PATH; // Bottom
    for(int r=2; r<10; r++) m->cells[r][0] = CELL_PATH; // Left (dejando hueco arriba)

    // Espiral interna
    for(int c=2; c<8; c++) m->cells[2][c] = CELL_PATH;
    for(int r=2; r<8; r++) m->cells[r][7] = CELL_PATH;
    for(int c=2; c<8; c++) m->cells[7][c] = CELL_PATH;
    for(int r=4; r<8; r++) m->cells[r][2] = CELL_PATH;

    // Centro (Salida)
    m->cells[4][3] = CELL_PATH;
    m->cells[4][4] = CELL_PATH;
    m->cells[4][5] = CELL_EXIT;
    m->exitRow = 4; m->exitCol = 5;

    // Trampas estratégicas
    m->cells[5][5] = CELL_TRAP;
    m->cells[2][4] = CELL_TRAP;

    // Inicio
    m->startRow = 0;
    m->startCol = 0;

    // MANTENEMOS VIDAS y SCORE del nivel anterior, solo reseteamos posición
    p->row = m->startRow;
    p->col = m->startCol;

    game->state = GAME_RUNNING;
}

int Game_TryMove(GameState *game, char dir)
{
    if (game->state != GAME_RUNNING) {
        return MOVE_INVALID;
    }

    Maze   *m = &game->maze;
    Player *p = &game->player;

    int newRow = p->row;
    int newCol = p->col;

    switch (dir) {
    case 'u':
    case 'U':
        newRow--;
        break;
    case 'd':
    case 'D':
        newRow++;
        break;
    case 'l':
    case 'L':
        newCol--;
        break;
    case 'r':
    case 'R':
        newCol++;
        break;
    default:
        return MOVE_INVALID;
    }

    // Verificamos límites de la matriz
    if (newRow < 0 || newRow >= m->rows ||
        newCol < 0 || newCol >= m->cols) {
        return MOVE_INVALID;
    }

    int cell = m->cells[newRow][newCol];

    // Si es muro, no se mueve
    if (cell == CELL_WALL) {
        return MOVE_INVALID;
    }

    // Actualizamos posición
    p->row = newRow;
    p->col = newCol;

    // Lógica según el tipo de celda
    if (cell == CELL_TRAP) {
        p->lives--;
        if (p->lives <= 0) {
            game->state = GAME_LOSE;
        } else {
            // Vuelve al inicio si aún tiene vidas
            p->row = m->startRow;
            p->col = m->startCol;
        }
        return MOVE_TRAP;
    }

    if (cell == CELL_EXIT) {
        game->state = GAME_WIN;
        p->score += 100;
        return MOVE_EXIT;
    }

    // Camino normal
    p->score += 1;
    return MOVE_OK;
}

int Game_HasFinished(const GameState *game)
{
    return game->state;
}
